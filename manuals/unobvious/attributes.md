# Атрибуты

В языке D достаточно много атрибутов:

`static` -- указывает что объявленная функция или поле относится к классу как к типу, а не к его экземплярам 

`extern` -- указывает какое соглашение о вызовах использовать

`abstract` -- абстрактные методы и классы

`final` -- указывает что метод/класс нельзя переопределить, методы финального класса все также финальны

`override` -- переопределение методов в дочерних классах должно помечаться этим атрибутом

`synchronized` -- "синтаксический сахар" для многопоточности, синхронизирует обращения из разных потоков (используется встроенный mutex класса при доступе к методу)

`scope` -- указывает область видимости для сущности, к которой применяется

`const` -- меняет тип ссылки с X на const(X), обращением к такой ссылке невозможно изменить данные по ней (но можно по не-константной ссылке)

`immutable` -- меняет тип с X на immutable(X), любые immutable переменные после инициализации не могут быть изменены

`inout` -- функция ведёт себя одинаково для обычных, const и immutable входных данных, но возвращает значение такого же типа (обычное/const/immutable)

`shared` -- изменяет тип переменной с X на shared(X), экземпляр такой переменной один для всех потоков программы (обычно изменяемые, или mutable, переменные хранятся в локальном хранилище каждого потока, по одной копии на поток)

`__gshared` -- то же самое что и `shared`, но не изменяет тип переменной. Использовать не рекомендуется и не безопасно, но иногда необходимо

`nothrow` -- компилятор гарантирует, что функция или метод не выбрасывают исключение

`pure` -- для функции гарантирует что она функционально чистая, т.е. при одинаковых входных данных возвращает одинаковые значения и не обладает побочными эффектами (не модифицирует переданные аргументы и глобальные переменные, не реагирует на исключения, не совершает операций ввода вывода и т.д.)

`ref` -- атрибут параметров и возвращаемого значения методов и функций, означает что передача будет по ссылке (pass-by-reference)

`return` -- (не путать с таким же ключевым словом) для `ref` функций гарантирует что возвращаемая ссылка не "переживёт" соответствующий ей аргумент

`@property` -- метод класса/структуры можно использовать как поле (`foo.a = 10; auto x = foo.a * 2`)
`@safe` -- memory-safe код
`@trusted` -- системный код, который можно вызывать из `@safe`
`@system` -- системный код (по умолчанию для всего кода)
`@nogc` -- внутри метода или функции запрещены обращения к сборщику мусора (выделение памяти через GC)
`@disable` -- можно отключить некоторые функции (конструктор по умолчанию у структур)

Какие-то из них используются с символом `@`, какие-то без. Какие-то можно объединить в логические группы,
какие-то нет. На начальных этапах можно обойтись вовсе без них, но с ростом уровня знания языка в атрибутах
появится необходимость, к тому же некоторые библиотеки используют их таким образом, что в своём коде придётся
с этим считаться.

## Безопасный и системный код

`@safe`, `@trusted`, `@system` -- реализуют 2 уровня безопасности кода (memory-safe и system) и промежуточный
слой между ними. Код без этих атрибутов по умолчанию `@system`. В коде, помеченном как `@safe` многие
операции с указателями запрещены. Зачастую требуется из `@safe` кода вызвать `@system` код. Для этого
используется `@trusted`. Но атрибутом можно пометить только функцию или метод, а иногда нужно пару операций,
для которых создавать отдельную функцию не удобно. Решается это таким образом:

```d
void foo(int a, int b) @safe
{
...
    () @trusted {
    ... блок системного кода ...
    } ();
...
}
```
Здесь мы внутри `foo`, помеченном как `@safe`, создаём `@trusted` делегат, который сразу же вызываем.

Использовать эту группу атрибутов имеет смысл, когда нужно гарантировать некоторый уровень безопасности, следовательно
применять `@trusted` нужно с [осторожностью (en)](https://dlang.org/blog/2016/09/28/how-to-write-trusted-code-in-d/).
